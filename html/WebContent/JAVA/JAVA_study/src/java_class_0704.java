public class java_class_0704 {
    public static void main(String[] args)  {
       
     /*    // 데이터 형변환
        
       int a = 85;
     //int(4) -> byte(1) : 강제 형변환 -> 데이터 손실이 일어날경우
     //      (변화될 타입)변수명
       byte b = (byte)a;
       
     //byte(1) -> int(4) : 자동 형변환
       b = 10;

       a = b;
     
   
     // int(4) -> float(4)
       float c = a;
     // float(4) -> int(4)
       a = (int)c ;
                
     */
    /* 
     //예제 1.다음 중 자동형 변환을 할 수 있는 것은?(모두 고르시오) d,e
     byte b = 10;
     char ch ='A';
     int i = 100;
     long l = 1000L;

     
    //int(4)->byte(1)    큰쪽에서 작은쪽 => 강제형변환
     b=(byte)i;           
    //byte(1)->char(2)   byte가 가지고 있는 음수값이 있기때문에 => 강제형변환  
     ch = (char)b;       
    //char(2)->short(2)  char가 포함할수 있는 값이 short의 최대범위보다 크기때문에 => 강제형변환
     short s = (short)ch; 
    //long(8)->float(4)  단순히 크기만 볼게 아니라 실수가 정수보다 크다 판단. => 자동형변환
     float f = l;        
    //char(2)->int(4)    작은쪽에서 큰쪽 => 자동형변환
    i = ch;             
    */
//---------------------------------------------------------------------------------------------------

    //--연산자--//
      
    //산술 연산자 (+,-,*,/,%)
          
    //비교 연산자 (>,<,>=,<=,==,!=)
    
    //논리 연산자 (&&,||,!)
    
    //대입 연산자 (=,+=,-=,*=,/=,%=)

    //삼항 연산자 (조건식?참:거짓) 


    /* 
     3. 연산자의 우선순위와 결합규칙

          -식에 사용된 연산자가 둘 이상일 경우, 연산자의 우선순위에 의해서 연산 순서가 결정된다.
          -단항 연산자가 이항 연산자보다 우선순위가 높다.
          -만일 우선순위가 확실하지 않다면, 먼저 계산되어야 하는 부분을 괄호를 묶어주어야 한다. 
           ()괄호 안의 계산식이 우선순위가 제일 높다.
          -연산자의 결합 규칙은 왼쪽에서 오른쪽 순서이지만, 대입 연산자( 제일 늦음 )는 오른쪽에서 왼쪽으로 진행된다.
          
          * 정리산술 > 비교 > 논리 > 대입 순서로 진행, 
          대입은 제일 마지막에 실행 단항( 1 ) > 이항( 2 ) > 삼항( 3 ) 순서로 진행 대입 
          연산자는 연산의 진행방향이 오른쪽에서 왼쪽이다.
          
          * 우선순위!!!최단산쉬관리삼대
          
          최우선 -> 단항 -> 산술 -> 쉬프트 -> 관계(비교) -> 논리 -> 삼항 -> 대입
          
      */

      int x = 2;
      int y = 5;
      char c = 'A';
 
    System.out.println(y >= 5 || x < 0 && x > 2); //true    &&연산자를 먼저 비교한 후에 ||연산자 비교 y>=5가 true값이라 => true
    System.out.println(y += 10 - x++);            //13      증가 되기전 x값 2로 계산 -> 5 += 10 - 2 => 13
    System.out.println(x+=2);                     //4       2+=2=4                 
    System.out.println(!('A' <= c&&c <= 'Z'));    //fasle   &&연자산자 값이 true인데 !(부정논리연산자) 연산자 작용으로 => false
    System.out.println('C'-c);                    //2       문자열char 'C'-문자열char'A' -> 아스키코드 적용 => 2 
    System.out.println('5'-'0');                  //5       ''(작은따옴표)로 묶었기 대문에 문자열 -> 아스키코드값 적용 -> 53-48 => 5
    System.out.println(c+1);                      //66      문자열char 'A'+ 숫자열int 1 -> 아스키코드 65 => 65+1=66
    System.out.println(++c);                      //B       증가 문자열'A' => 문자열'B'
    System.out.println(c++);                      //A       증가 되기전 문자열 'A' => 'A'    System.out.println(c); //A

    }
}

